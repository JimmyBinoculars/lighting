// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: UsbProConfigMessages.proto

#include "UsbProConfigMessages.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_UsbProConfigMessages_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ParameterReply_UsbProConfigMessages_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_UsbProConfigMessages_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ParameterRequest_UsbProConfigMessages_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_UsbProConfigMessages_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PortAssignmentReply_UsbProConfigMessages_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_UsbProConfigMessages_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SerialNumberReply_UsbProConfigMessages_2eproto;
namespace ola {
namespace plugin {
namespace usbpro {
class ParameterReplyDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ParameterReply> _instance;
} _ParameterReply_default_instance_;
class ParameterRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ParameterRequest> _instance;
} _ParameterRequest_default_instance_;
class SerialNumberReplyDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SerialNumberReply> _instance;
} _SerialNumberReply_default_instance_;
class PortAssignmentReplyDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PortAssignmentReply> _instance;
} _PortAssignmentReply_default_instance_;
class RequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Request> _instance;
} _Request_default_instance_;
class ReplyDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Reply> _instance;
} _Reply_default_instance_;
}  // namespace usbpro
}  // namespace plugin
}  // namespace ola
static void InitDefaultsscc_info_ParameterReply_UsbProConfigMessages_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ola::plugin::usbpro::_ParameterReply_default_instance_;
    new (ptr) ::ola::plugin::usbpro::ParameterReply();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ola::plugin::usbpro::ParameterReply::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ParameterReply_UsbProConfigMessages_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ParameterReply_UsbProConfigMessages_2eproto}, {}};

static void InitDefaultsscc_info_ParameterRequest_UsbProConfigMessages_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ola::plugin::usbpro::_ParameterRequest_default_instance_;
    new (ptr) ::ola::plugin::usbpro::ParameterRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ola::plugin::usbpro::ParameterRequest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ParameterRequest_UsbProConfigMessages_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ParameterRequest_UsbProConfigMessages_2eproto}, {}};

static void InitDefaultsscc_info_PortAssignmentReply_UsbProConfigMessages_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ola::plugin::usbpro::_PortAssignmentReply_default_instance_;
    new (ptr) ::ola::plugin::usbpro::PortAssignmentReply();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ola::plugin::usbpro::PortAssignmentReply::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PortAssignmentReply_UsbProConfigMessages_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_PortAssignmentReply_UsbProConfigMessages_2eproto}, {}};

static void InitDefaultsscc_info_Reply_UsbProConfigMessages_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ola::plugin::usbpro::_Reply_default_instance_;
    new (ptr) ::ola::plugin::usbpro::Reply();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ola::plugin::usbpro::Reply::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_Reply_UsbProConfigMessages_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_Reply_UsbProConfigMessages_2eproto}, {
      &scc_info_ParameterReply_UsbProConfigMessages_2eproto.base,
      &scc_info_SerialNumberReply_UsbProConfigMessages_2eproto.base,
      &scc_info_PortAssignmentReply_UsbProConfigMessages_2eproto.base,}};

static void InitDefaultsscc_info_Request_UsbProConfigMessages_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ola::plugin::usbpro::_Request_default_instance_;
    new (ptr) ::ola::plugin::usbpro::Request();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ola::plugin::usbpro::Request::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Request_UsbProConfigMessages_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_Request_UsbProConfigMessages_2eproto}, {
      &scc_info_ParameterRequest_UsbProConfigMessages_2eproto.base,}};

static void InitDefaultsscc_info_SerialNumberReply_UsbProConfigMessages_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::ola::plugin::usbpro::_SerialNumberReply_default_instance_;
    new (ptr) ::ola::plugin::usbpro::SerialNumberReply();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ola::plugin::usbpro::SerialNumberReply::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SerialNumberReply_UsbProConfigMessages_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_SerialNumberReply_UsbProConfigMessages_2eproto}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_UsbProConfigMessages_2eproto[6];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_UsbProConfigMessages_2eproto[2];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_UsbProConfigMessages_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_UsbProConfigMessages_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::ParameterReply, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::ParameterReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::ParameterReply, firmware_high_),
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::ParameterReply, firmware_),
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::ParameterReply, break_time_),
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::ParameterReply, mab_time_),
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::ParameterReply, rate_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::ParameterRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::ParameterRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::ParameterRequest, port_id_),
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::ParameterRequest, break_time_),
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::ParameterRequest, mab_time_),
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::ParameterRequest, rate_),
  3,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::SerialNumberReply, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::SerialNumberReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::SerialNumberReply, serial_),
  0,
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::PortAssignmentReply, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::PortAssignmentReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::PortAssignmentReply, port_assignment1_),
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::PortAssignmentReply, port_assignment2_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::Request, type_),
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::Request, parameters_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::Reply, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::Reply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::Reply, type_),
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::Reply, parameters_),
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::Reply, serial_number_),
  PROTOBUF_FIELD_OFFSET(::ola::plugin::usbpro::Reply, port_assignment_),
  3,
  0,
  1,
  2,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 10, sizeof(::ola::plugin::usbpro::ParameterReply)},
  { 15, 24, sizeof(::ola::plugin::usbpro::ParameterRequest)},
  { 28, 34, sizeof(::ola::plugin::usbpro::SerialNumberReply)},
  { 35, 42, sizeof(::ola::plugin::usbpro::PortAssignmentReply)},
  { 44, 51, sizeof(::ola::plugin::usbpro::Request)},
  { 53, 62, sizeof(::ola::plugin::usbpro::Reply)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::ola::plugin::usbpro::_ParameterReply_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::ola::plugin::usbpro::_ParameterRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::ola::plugin::usbpro::_SerialNumberReply_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::ola::plugin::usbpro::_PortAssignmentReply_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::ola::plugin::usbpro::_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::ola::plugin::usbpro::_Reply_default_instance_),
};

const char descriptor_table_protodef_UsbProConfigMessages_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\032UsbProConfigMessages.proto\022\021ola.plugin"
  ".usbpro\"m\n\016ParameterReply\022\025\n\rfirmware_hi"
  "gh\030\001 \002(\r\022\020\n\010firmware\030\002 \002(\r\022\022\n\nbreak_time"
  "\030\003 \002(\r\022\020\n\010mab_time\030\004 \002(\r\022\014\n\004rate\030\005 \002(\r\"W"
  "\n\020ParameterRequest\022\017\n\007port_id\030\004 \002(\r\022\022\n\nb"
  "reak_time\030\001 \001(\r\022\020\n\010mab_time\030\002 \001(\r\022\014\n\004rat"
  "e\030\003 \001(\r\"#\n\021SerialNumberReply\022\016\n\006serial\030\001"
  " \002(\t\"I\n\023PortAssignmentReply\022\030\n\020port_assi"
  "gnment1\030\001 \002(\r\022\030\n\020port_assignment2\030\002 \002(\r\""
  "\344\001\n\007Request\0224\n\004type\030\001 \002(\0162&.ola.plugin.u"
  "sbpro.Request.RequestType\0227\n\nparameters\030"
  "\002 \001(\0132#.ola.plugin.usbpro.ParameterReque"
  "st\"j\n\013RequestType\022\034\n\030USBPRO_PARAMETER_RE"
  "QUEST\020\001\022\031\n\025USBPRO_SERIAL_REQUEST\020\002\022\"\n\036US"
  "BPRO_PORT_ASSIGNMENT_REQUEST\020\003\"\322\002\n\005Reply"
  "\0220\n\004type\030\001 \002(\0162\".ola.plugin.usbpro.Reply"
  ".ReplyType\0225\n\nparameters\030\002 \001(\0132!.ola.plu"
  "gin.usbpro.ParameterReply\022;\n\rserial_numb"
  "er\030\003 \001(\0132$.ola.plugin.usbpro.SerialNumbe"
  "rReply\022\?\n\017port_assignment\030\004 \001(\0132&.ola.pl"
  "ugin.usbpro.PortAssignmentReply\"b\n\tReply"
  "Type\022\032\n\026USBPRO_PARAMETER_REPLY\020\001\022\027\n\023USBP"
  "RO_SERIAL_REPLY\020\002\022 \n\034USBPRO_PORT_ASSIGNM"
  "ENT_REPLY\020\003"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_UsbProConfigMessages_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_UsbProConfigMessages_2eproto_sccs[6] = {
  &scc_info_ParameterReply_UsbProConfigMessages_2eproto.base,
  &scc_info_ParameterRequest_UsbProConfigMessages_2eproto.base,
  &scc_info_PortAssignmentReply_UsbProConfigMessages_2eproto.base,
  &scc_info_Reply_UsbProConfigMessages_2eproto.base,
  &scc_info_Request_UsbProConfigMessages_2eproto.base,
  &scc_info_SerialNumberReply_UsbProConfigMessages_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_UsbProConfigMessages_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_UsbProConfigMessages_2eproto = {
  false, false, descriptor_table_protodef_UsbProConfigMessages_2eproto, "UsbProConfigMessages.proto", 931,
  &descriptor_table_UsbProConfigMessages_2eproto_once, descriptor_table_UsbProConfigMessages_2eproto_sccs, descriptor_table_UsbProConfigMessages_2eproto_deps, 6, 0,
  schemas, file_default_instances, TableStruct_UsbProConfigMessages_2eproto::offsets,
  file_level_metadata_UsbProConfigMessages_2eproto, 6, file_level_enum_descriptors_UsbProConfigMessages_2eproto, file_level_service_descriptors_UsbProConfigMessages_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_UsbProConfigMessages_2eproto = (static_cast<void>(::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_UsbProConfigMessages_2eproto)), true);
namespace ola {
namespace plugin {
namespace usbpro {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Request_RequestType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_UsbProConfigMessages_2eproto);
  return file_level_enum_descriptors_UsbProConfigMessages_2eproto[0];
}
bool Request_RequestType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Request_RequestType Request::USBPRO_PARAMETER_REQUEST;
constexpr Request_RequestType Request::USBPRO_SERIAL_REQUEST;
constexpr Request_RequestType Request::USBPRO_PORT_ASSIGNMENT_REQUEST;
constexpr Request_RequestType Request::RequestType_MIN;
constexpr Request_RequestType Request::RequestType_MAX;
constexpr int Request::RequestType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Reply_ReplyType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_UsbProConfigMessages_2eproto);
  return file_level_enum_descriptors_UsbProConfigMessages_2eproto[1];
}
bool Reply_ReplyType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Reply_ReplyType Reply::USBPRO_PARAMETER_REPLY;
constexpr Reply_ReplyType Reply::USBPRO_SERIAL_REPLY;
constexpr Reply_ReplyType Reply::USBPRO_PORT_ASSIGNMENT_REPLY;
constexpr Reply_ReplyType Reply::ReplyType_MIN;
constexpr Reply_ReplyType Reply::ReplyType_MAX;
constexpr int Reply::ReplyType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void ParameterReply::InitAsDefaultInstance() {
}
class ParameterReply::_Internal {
 public:
  using HasBits = decltype(std::declval<ParameterReply>()._has_bits_);
  static void set_has_firmware_high(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_firmware(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_break_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mab_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

ParameterReply::ParameterReply(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:ola.plugin.usbpro.ParameterReply)
}
ParameterReply::ParameterReply(const ParameterReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&firmware_high_, &from.firmware_high_,
    static_cast<size_t>(reinterpret_cast<char*>(&rate_) -
    reinterpret_cast<char*>(&firmware_high_)) + sizeof(rate_));
  // @@protoc_insertion_point(copy_constructor:ola.plugin.usbpro.ParameterReply)
}

void ParameterReply::SharedCtor() {
  ::memset(&firmware_high_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&rate_) -
      reinterpret_cast<char*>(&firmware_high_)) + sizeof(rate_));
}

ParameterReply::~ParameterReply() {
  // @@protoc_insertion_point(destructor:ola.plugin.usbpro.ParameterReply)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ParameterReply::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void ParameterReply::ArenaDtor(void* object) {
  ParameterReply* _this = reinterpret_cast< ParameterReply* >(object);
  (void)_this;
}
void ParameterReply::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ParameterReply::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ParameterReply& ParameterReply::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ParameterReply_UsbProConfigMessages_2eproto.base);
  return *internal_default_instance();
}


void ParameterReply::Clear() {
// @@protoc_insertion_point(message_clear_start:ola.plugin.usbpro.ParameterReply)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&firmware_high_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rate_) -
        reinterpret_cast<char*>(&firmware_high_)) + sizeof(rate_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ParameterReply::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 firmware_high = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_firmware_high(&has_bits);
          firmware_high_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 firmware = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_firmware(&has_bits);
          firmware_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 break_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_break_time(&has_bits);
          break_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 mab_time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_mab_time(&has_bits);
          mab_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 rate = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_rate(&has_bits);
          rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ParameterReply::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ola.plugin.usbpro.ParameterReply)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 firmware_high = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_firmware_high(), target);
  }

  // required uint32 firmware = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_firmware(), target);
  }

  // required uint32 break_time = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_break_time(), target);
  }

  // required uint32 mab_time = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_mab_time(), target);
  }

  // required uint32 rate = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_rate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ola.plugin.usbpro.ParameterReply)
  return target;
}

size_t ParameterReply::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ola.plugin.usbpro.ParameterReply)
  size_t total_size = 0;

  if (_internal_has_firmware_high()) {
    // required uint32 firmware_high = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_firmware_high());
  }

  if (_internal_has_firmware()) {
    // required uint32 firmware = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_firmware());
  }

  if (_internal_has_break_time()) {
    // required uint32 break_time = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_break_time());
  }

  if (_internal_has_mab_time()) {
    // required uint32 mab_time = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_mab_time());
  }

  if (_internal_has_rate()) {
    // required uint32 rate = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_rate());
  }

  return total_size;
}
size_t ParameterReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ola.plugin.usbpro.ParameterReply)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required uint32 firmware_high = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_firmware_high());

    // required uint32 firmware = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_firmware());

    // required uint32 break_time = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_break_time());

    // required uint32 mab_time = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_mab_time());

    // required uint32 rate = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_rate());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ParameterReply::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:ola.plugin.usbpro.ParameterReply)
  GOOGLE_DCHECK_NE(&from, this);
  const ParameterReply* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ParameterReply>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ola.plugin.usbpro.ParameterReply)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:ola.plugin.usbpro.ParameterReply)
    MergeFrom(*source);
  }
}

void ParameterReply::MergeFrom(const ParameterReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ola.plugin.usbpro.ParameterReply)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      firmware_high_ = from.firmware_high_;
    }
    if (cached_has_bits & 0x00000002u) {
      firmware_ = from.firmware_;
    }
    if (cached_has_bits & 0x00000004u) {
      break_time_ = from.break_time_;
    }
    if (cached_has_bits & 0x00000008u) {
      mab_time_ = from.mab_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      rate_ = from.rate_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ParameterReply::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:ola.plugin.usbpro.ParameterReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ParameterReply::CopyFrom(const ParameterReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ola.plugin.usbpro.ParameterReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ParameterReply::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ParameterReply::InternalSwap(ParameterReply* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ParameterReply, rate_)
      + sizeof(ParameterReply::rate_)
      - PROTOBUF_FIELD_OFFSET(ParameterReply, firmware_high_)>(
          reinterpret_cast<char*>(&firmware_high_),
          reinterpret_cast<char*>(&other->firmware_high_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ParameterReply::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ParameterRequest::InitAsDefaultInstance() {
}
class ParameterRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ParameterRequest>()._has_bits_);
  static void set_has_port_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_break_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_mab_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000008) ^ 0x00000008) != 0;
  }
};

ParameterRequest::ParameterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:ola.plugin.usbpro.ParameterRequest)
}
ParameterRequest::ParameterRequest(const ParameterRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&break_time_, &from.break_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&port_id_) -
    reinterpret_cast<char*>(&break_time_)) + sizeof(port_id_));
  // @@protoc_insertion_point(copy_constructor:ola.plugin.usbpro.ParameterRequest)
}

void ParameterRequest::SharedCtor() {
  ::memset(&break_time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&port_id_) -
      reinterpret_cast<char*>(&break_time_)) + sizeof(port_id_));
}

ParameterRequest::~ParameterRequest() {
  // @@protoc_insertion_point(destructor:ola.plugin.usbpro.ParameterRequest)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ParameterRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void ParameterRequest::ArenaDtor(void* object) {
  ParameterRequest* _this = reinterpret_cast< ParameterRequest* >(object);
  (void)_this;
}
void ParameterRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ParameterRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ParameterRequest& ParameterRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ParameterRequest_UsbProConfigMessages_2eproto.base);
  return *internal_default_instance();
}


void ParameterRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ola.plugin.usbpro.ParameterRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&break_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&port_id_) -
        reinterpret_cast<char*>(&break_time_)) + sizeof(port_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ParameterRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 break_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_break_time(&has_bits);
          break_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 mab_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_mab_time(&has_bits);
          mab_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 rate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_rate(&has_bits);
          rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 port_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_port_id(&has_bits);
          port_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ParameterRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ola.plugin.usbpro.ParameterRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 break_time = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_break_time(), target);
  }

  // optional uint32 mab_time = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_mab_time(), target);
  }

  // optional uint32 rate = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_rate(), target);
  }

  // required uint32 port_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_port_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ola.plugin.usbpro.ParameterRequest)
  return target;
}

size_t ParameterRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ola.plugin.usbpro.ParameterRequest)
  size_t total_size = 0;

  // required uint32 port_id = 4;
  if (_internal_has_port_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_port_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 break_time = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_break_time());
    }

    // optional uint32 mab_time = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_mab_time());
    }

    // optional uint32 rate = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_rate());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ParameterRequest::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:ola.plugin.usbpro.ParameterRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const ParameterRequest* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ParameterRequest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ola.plugin.usbpro.ParameterRequest)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:ola.plugin.usbpro.ParameterRequest)
    MergeFrom(*source);
  }
}

void ParameterRequest::MergeFrom(const ParameterRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ola.plugin.usbpro.ParameterRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      break_time_ = from.break_time_;
    }
    if (cached_has_bits & 0x00000002u) {
      mab_time_ = from.mab_time_;
    }
    if (cached_has_bits & 0x00000004u) {
      rate_ = from.rate_;
    }
    if (cached_has_bits & 0x00000008u) {
      port_id_ = from.port_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ParameterRequest::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:ola.plugin.usbpro.ParameterRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ParameterRequest::CopyFrom(const ParameterRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ola.plugin.usbpro.ParameterRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ParameterRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ParameterRequest::InternalSwap(ParameterRequest* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ParameterRequest, port_id_)
      + sizeof(ParameterRequest::port_id_)
      - PROTOBUF_FIELD_OFFSET(ParameterRequest, break_time_)>(
          reinterpret_cast<char*>(&break_time_),
          reinterpret_cast<char*>(&other->break_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ParameterRequest::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SerialNumberReply::InitAsDefaultInstance() {
}
class SerialNumberReply::_Internal {
 public:
  using HasBits = decltype(std::declval<SerialNumberReply>()._has_bits_);
  static void set_has_serial(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SerialNumberReply::SerialNumberReply(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:ola.plugin.usbpro.SerialNumberReply)
}
SerialNumberReply::SerialNumberReply(const SerialNumberReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  serial_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_serial()) {
    serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_serial(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:ola.plugin.usbpro.SerialNumberReply)
}

void SerialNumberReply::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SerialNumberReply_UsbProConfigMessages_2eproto.base);
  serial_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

SerialNumberReply::~SerialNumberReply() {
  // @@protoc_insertion_point(destructor:ola.plugin.usbpro.SerialNumberReply)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SerialNumberReply::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  serial_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SerialNumberReply::ArenaDtor(void* object) {
  SerialNumberReply* _this = reinterpret_cast< SerialNumberReply* >(object);
  (void)_this;
}
void SerialNumberReply::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SerialNumberReply::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SerialNumberReply& SerialNumberReply::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SerialNumberReply_UsbProConfigMessages_2eproto.base);
  return *internal_default_instance();
}


void SerialNumberReply::Clear() {
// @@protoc_insertion_point(message_clear_start:ola.plugin.usbpro.SerialNumberReply)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    serial_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SerialNumberReply::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string serial = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_serial();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "ola.plugin.usbpro.SerialNumberReply.serial");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SerialNumberReply::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ola.plugin.usbpro.SerialNumberReply)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string serial = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_serial().data(), static_cast<int>(this->_internal_serial().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "ola.plugin.usbpro.SerialNumberReply.serial");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_serial(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ola.plugin.usbpro.SerialNumberReply)
  return target;
}

size_t SerialNumberReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ola.plugin.usbpro.SerialNumberReply)
  size_t total_size = 0;

  // required string serial = 1;
  if (_internal_has_serial()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_serial());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SerialNumberReply::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:ola.plugin.usbpro.SerialNumberReply)
  GOOGLE_DCHECK_NE(&from, this);
  const SerialNumberReply* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SerialNumberReply>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ola.plugin.usbpro.SerialNumberReply)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:ola.plugin.usbpro.SerialNumberReply)
    MergeFrom(*source);
  }
}

void SerialNumberReply::MergeFrom(const SerialNumberReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ola.plugin.usbpro.SerialNumberReply)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_serial()) {
    _internal_set_serial(from._internal_serial());
  }
}

void SerialNumberReply::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:ola.plugin.usbpro.SerialNumberReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SerialNumberReply::CopyFrom(const SerialNumberReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ola.plugin.usbpro.SerialNumberReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SerialNumberReply::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void SerialNumberReply::InternalSwap(SerialNumberReply* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  serial_.Swap(&other->serial_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata SerialNumberReply::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void PortAssignmentReply::InitAsDefaultInstance() {
}
class PortAssignmentReply::_Internal {
 public:
  using HasBits = decltype(std::declval<PortAssignmentReply>()._has_bits_);
  static void set_has_port_assignment1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_port_assignment2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

PortAssignmentReply::PortAssignmentReply(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:ola.plugin.usbpro.PortAssignmentReply)
}
PortAssignmentReply::PortAssignmentReply(const PortAssignmentReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&port_assignment1_, &from.port_assignment1_,
    static_cast<size_t>(reinterpret_cast<char*>(&port_assignment2_) -
    reinterpret_cast<char*>(&port_assignment1_)) + sizeof(port_assignment2_));
  // @@protoc_insertion_point(copy_constructor:ola.plugin.usbpro.PortAssignmentReply)
}

void PortAssignmentReply::SharedCtor() {
  ::memset(&port_assignment1_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&port_assignment2_) -
      reinterpret_cast<char*>(&port_assignment1_)) + sizeof(port_assignment2_));
}

PortAssignmentReply::~PortAssignmentReply() {
  // @@protoc_insertion_point(destructor:ola.plugin.usbpro.PortAssignmentReply)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void PortAssignmentReply::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void PortAssignmentReply::ArenaDtor(void* object) {
  PortAssignmentReply* _this = reinterpret_cast< PortAssignmentReply* >(object);
  (void)_this;
}
void PortAssignmentReply::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PortAssignmentReply::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PortAssignmentReply& PortAssignmentReply::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PortAssignmentReply_UsbProConfigMessages_2eproto.base);
  return *internal_default_instance();
}


void PortAssignmentReply::Clear() {
// @@protoc_insertion_point(message_clear_start:ola.plugin.usbpro.PortAssignmentReply)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&port_assignment1_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&port_assignment2_) -
        reinterpret_cast<char*>(&port_assignment1_)) + sizeof(port_assignment2_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PortAssignmentReply::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 port_assignment1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_port_assignment1(&has_bits);
          port_assignment1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 port_assignment2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_port_assignment2(&has_bits);
          port_assignment2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PortAssignmentReply::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ola.plugin.usbpro.PortAssignmentReply)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 port_assignment1 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_port_assignment1(), target);
  }

  // required uint32 port_assignment2 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_port_assignment2(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ola.plugin.usbpro.PortAssignmentReply)
  return target;
}

size_t PortAssignmentReply::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ola.plugin.usbpro.PortAssignmentReply)
  size_t total_size = 0;

  if (_internal_has_port_assignment1()) {
    // required uint32 port_assignment1 = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_port_assignment1());
  }

  if (_internal_has_port_assignment2()) {
    // required uint32 port_assignment2 = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_port_assignment2());
  }

  return total_size;
}
size_t PortAssignmentReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ola.plugin.usbpro.PortAssignmentReply)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 port_assignment1 = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_port_assignment1());

    // required uint32 port_assignment2 = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_port_assignment2());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PortAssignmentReply::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:ola.plugin.usbpro.PortAssignmentReply)
  GOOGLE_DCHECK_NE(&from, this);
  const PortAssignmentReply* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<PortAssignmentReply>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ola.plugin.usbpro.PortAssignmentReply)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:ola.plugin.usbpro.PortAssignmentReply)
    MergeFrom(*source);
  }
}

void PortAssignmentReply::MergeFrom(const PortAssignmentReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ola.plugin.usbpro.PortAssignmentReply)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      port_assignment1_ = from.port_assignment1_;
    }
    if (cached_has_bits & 0x00000002u) {
      port_assignment2_ = from.port_assignment2_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PortAssignmentReply::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:ola.plugin.usbpro.PortAssignmentReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PortAssignmentReply::CopyFrom(const PortAssignmentReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ola.plugin.usbpro.PortAssignmentReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PortAssignmentReply::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void PortAssignmentReply::InternalSwap(PortAssignmentReply* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PortAssignmentReply, port_assignment2_)
      + sizeof(PortAssignmentReply::port_assignment2_)
      - PROTOBUF_FIELD_OFFSET(PortAssignmentReply, port_assignment1_)>(
          reinterpret_cast<char*>(&port_assignment1_),
          reinterpret_cast<char*>(&other->port_assignment1_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PortAssignmentReply::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Request::InitAsDefaultInstance() {
  ::ola::plugin::usbpro::_Request_default_instance_._instance.get_mutable()->parameters_ = const_cast< ::ola::plugin::usbpro::ParameterRequest*>(
      ::ola::plugin::usbpro::ParameterRequest::internal_default_instance());
}
class Request::_Internal {
 public:
  using HasBits = decltype(std::declval<Request>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::ola::plugin::usbpro::ParameterRequest& parameters(const Request* msg);
  static void set_has_parameters(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

const ::ola::plugin::usbpro::ParameterRequest&
Request::_Internal::parameters(const Request* msg) {
  return *msg->parameters_;
}
Request::Request(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:ola.plugin.usbpro.Request)
}
Request::Request(const Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_parameters()) {
    parameters_ = new ::ola::plugin::usbpro::ParameterRequest(*from.parameters_);
  } else {
    parameters_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:ola.plugin.usbpro.Request)
}

void Request::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Request_UsbProConfigMessages_2eproto.base);
  parameters_ = nullptr;
  type_ = 1;
}

Request::~Request() {
  // @@protoc_insertion_point(destructor:ola.plugin.usbpro.Request)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Request::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete parameters_;
}

void Request::ArenaDtor(void* object) {
  Request* _this = reinterpret_cast< Request* >(object);
  (void)_this;
}
void Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Request& Request::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Request_UsbProConfigMessages_2eproto.base);
  return *internal_default_instance();
}


void Request::Clear() {
// @@protoc_insertion_point(message_clear_start:ola.plugin.usbpro.Request)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(parameters_ != nullptr);
      parameters_->Clear();
    }
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .ola.plugin.usbpro.Request.RequestType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ola::plugin::usbpro::Request_RequestType_IsValid(val))) {
            _internal_set_type(static_cast<::ola::plugin::usbpro::Request_RequestType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .ola.plugin.usbpro.ParameterRequest parameters = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_parameters(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Request::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ola.plugin.usbpro.Request)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .ola.plugin.usbpro.Request.RequestType type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional .ola.plugin.usbpro.ParameterRequest parameters = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::parameters(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ola.plugin.usbpro.Request)
  return target;
}

size_t Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ola.plugin.usbpro.Request)
  size_t total_size = 0;

  // required .ola.plugin.usbpro.Request.RequestType type = 1;
  if (_internal_has_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .ola.plugin.usbpro.ParameterRequest parameters = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *parameters_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Request::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:ola.plugin.usbpro.Request)
  GOOGLE_DCHECK_NE(&from, this);
  const Request* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Request>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ola.plugin.usbpro.Request)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:ola.plugin.usbpro.Request)
    MergeFrom(*source);
  }
}

void Request::MergeFrom(const Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ola.plugin.usbpro.Request)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_parameters()->::ola::plugin::usbpro::ParameterRequest::MergeFrom(from._internal_parameters());
    }
    if (cached_has_bits & 0x00000002u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Request::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:ola.plugin.usbpro.Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Request::CopyFrom(const Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ola.plugin.usbpro.Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Request::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_parameters()) {
    if (!parameters_->IsInitialized()) return false;
  }
  return true;
}

void Request::InternalSwap(Request* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(parameters_, other->parameters_);
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Request::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Reply::InitAsDefaultInstance() {
  ::ola::plugin::usbpro::_Reply_default_instance_._instance.get_mutable()->parameters_ = const_cast< ::ola::plugin::usbpro::ParameterReply*>(
      ::ola::plugin::usbpro::ParameterReply::internal_default_instance());
  ::ola::plugin::usbpro::_Reply_default_instance_._instance.get_mutable()->serial_number_ = const_cast< ::ola::plugin::usbpro::SerialNumberReply*>(
      ::ola::plugin::usbpro::SerialNumberReply::internal_default_instance());
  ::ola::plugin::usbpro::_Reply_default_instance_._instance.get_mutable()->port_assignment_ = const_cast< ::ola::plugin::usbpro::PortAssignmentReply*>(
      ::ola::plugin::usbpro::PortAssignmentReply::internal_default_instance());
}
class Reply::_Internal {
 public:
  using HasBits = decltype(std::declval<Reply>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::ola::plugin::usbpro::ParameterReply& parameters(const Reply* msg);
  static void set_has_parameters(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ola::plugin::usbpro::SerialNumberReply& serial_number(const Reply* msg);
  static void set_has_serial_number(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::ola::plugin::usbpro::PortAssignmentReply& port_assignment(const Reply* msg);
  static void set_has_port_assignment(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000008) ^ 0x00000008) != 0;
  }
};

const ::ola::plugin::usbpro::ParameterReply&
Reply::_Internal::parameters(const Reply* msg) {
  return *msg->parameters_;
}
const ::ola::plugin::usbpro::SerialNumberReply&
Reply::_Internal::serial_number(const Reply* msg) {
  return *msg->serial_number_;
}
const ::ola::plugin::usbpro::PortAssignmentReply&
Reply::_Internal::port_assignment(const Reply* msg) {
  return *msg->port_assignment_;
}
Reply::Reply(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:ola.plugin.usbpro.Reply)
}
Reply::Reply(const Reply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_parameters()) {
    parameters_ = new ::ola::plugin::usbpro::ParameterReply(*from.parameters_);
  } else {
    parameters_ = nullptr;
  }
  if (from._internal_has_serial_number()) {
    serial_number_ = new ::ola::plugin::usbpro::SerialNumberReply(*from.serial_number_);
  } else {
    serial_number_ = nullptr;
  }
  if (from._internal_has_port_assignment()) {
    port_assignment_ = new ::ola::plugin::usbpro::PortAssignmentReply(*from.port_assignment_);
  } else {
    port_assignment_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:ola.plugin.usbpro.Reply)
}

void Reply::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Reply_UsbProConfigMessages_2eproto.base);
  ::memset(&parameters_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&port_assignment_) -
      reinterpret_cast<char*>(&parameters_)) + sizeof(port_assignment_));
  type_ = 1;
}

Reply::~Reply() {
  // @@protoc_insertion_point(destructor:ola.plugin.usbpro.Reply)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Reply::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete parameters_;
  if (this != internal_default_instance()) delete serial_number_;
  if (this != internal_default_instance()) delete port_assignment_;
}

void Reply::ArenaDtor(void* object) {
  Reply* _this = reinterpret_cast< Reply* >(object);
  (void)_this;
}
void Reply::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Reply::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Reply& Reply::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Reply_UsbProConfigMessages_2eproto.base);
  return *internal_default_instance();
}


void Reply::Clear() {
// @@protoc_insertion_point(message_clear_start:ola.plugin.usbpro.Reply)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(parameters_ != nullptr);
      parameters_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(serial_number_ != nullptr);
      serial_number_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(port_assignment_ != nullptr);
      port_assignment_->Clear();
    }
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Reply::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .ola.plugin.usbpro.Reply.ReplyType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ola::plugin::usbpro::Reply_ReplyType_IsValid(val))) {
            _internal_set_type(static_cast<::ola::plugin::usbpro::Reply_ReplyType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .ola.plugin.usbpro.ParameterReply parameters = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_parameters(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ola.plugin.usbpro.SerialNumberReply serial_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_serial_number(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ola.plugin.usbpro.PortAssignmentReply port_assignment = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_port_assignment(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Reply::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ola.plugin.usbpro.Reply)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .ola.plugin.usbpro.Reply.ReplyType type = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional .ola.plugin.usbpro.ParameterReply parameters = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::parameters(this), target, stream);
  }

  // optional .ola.plugin.usbpro.SerialNumberReply serial_number = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::serial_number(this), target, stream);
  }

  // optional .ola.plugin.usbpro.PortAssignmentReply port_assignment = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::port_assignment(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ola.plugin.usbpro.Reply)
  return target;
}

size_t Reply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ola.plugin.usbpro.Reply)
  size_t total_size = 0;

  // required .ola.plugin.usbpro.Reply.ReplyType type = 1;
  if (_internal_has_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .ola.plugin.usbpro.ParameterReply parameters = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *parameters_);
    }

    // optional .ola.plugin.usbpro.SerialNumberReply serial_number = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *serial_number_);
    }

    // optional .ola.plugin.usbpro.PortAssignmentReply port_assignment = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *port_assignment_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Reply::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:ola.plugin.usbpro.Reply)
  GOOGLE_DCHECK_NE(&from, this);
  const Reply* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Reply>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ola.plugin.usbpro.Reply)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:ola.plugin.usbpro.Reply)
    MergeFrom(*source);
  }
}

void Reply::MergeFrom(const Reply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ola.plugin.usbpro.Reply)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_parameters()->::ola::plugin::usbpro::ParameterReply::MergeFrom(from._internal_parameters());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_serial_number()->::ola::plugin::usbpro::SerialNumberReply::MergeFrom(from._internal_serial_number());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_port_assignment()->::ola::plugin::usbpro::PortAssignmentReply::MergeFrom(from._internal_port_assignment());
    }
    if (cached_has_bits & 0x00000008u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Reply::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:ola.plugin.usbpro.Reply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Reply::CopyFrom(const Reply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ola.plugin.usbpro.Reply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Reply::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_parameters()) {
    if (!parameters_->IsInitialized()) return false;
  }
  if (_internal_has_serial_number()) {
    if (!serial_number_->IsInitialized()) return false;
  }
  if (_internal_has_port_assignment()) {
    if (!port_assignment_->IsInitialized()) return false;
  }
  return true;
}

void Reply::InternalSwap(Reply* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Reply, port_assignment_)
      + sizeof(Reply::port_assignment_)
      - PROTOBUF_FIELD_OFFSET(Reply, parameters_)>(
          reinterpret_cast<char*>(&parameters_),
          reinterpret_cast<char*>(&other->parameters_));
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Reply::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace usbpro
}  // namespace plugin
}  // namespace ola
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::ola::plugin::usbpro::ParameterReply* Arena::CreateMaybeMessage< ::ola::plugin::usbpro::ParameterReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ola::plugin::usbpro::ParameterReply >(arena);
}
template<> PROTOBUF_NOINLINE ::ola::plugin::usbpro::ParameterRequest* Arena::CreateMaybeMessage< ::ola::plugin::usbpro::ParameterRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ola::plugin::usbpro::ParameterRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::ola::plugin::usbpro::SerialNumberReply* Arena::CreateMaybeMessage< ::ola::plugin::usbpro::SerialNumberReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ola::plugin::usbpro::SerialNumberReply >(arena);
}
template<> PROTOBUF_NOINLINE ::ola::plugin::usbpro::PortAssignmentReply* Arena::CreateMaybeMessage< ::ola::plugin::usbpro::PortAssignmentReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ola::plugin::usbpro::PortAssignmentReply >(arena);
}
template<> PROTOBUF_NOINLINE ::ola::plugin::usbpro::Request* Arena::CreateMaybeMessage< ::ola::plugin::usbpro::Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ola::plugin::usbpro::Request >(arena);
}
template<> PROTOBUF_NOINLINE ::ola::plugin::usbpro::Reply* Arena::CreateMaybeMessage< ::ola::plugin::usbpro::Reply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ola::plugin::usbpro::Reply >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
