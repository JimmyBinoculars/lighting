// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: E131ConfigMessages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_E131ConfigMessages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_E131ConfigMessages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_E131ConfigMessages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_E131ConfigMessages_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_E131ConfigMessages_2eproto;
namespace ola {
namespace plugin {
namespace e131 {
class InputPortInfo;
class InputPortInfoDefaultTypeInternal;
extern InputPortInfoDefaultTypeInternal _InputPortInfo_default_instance_;
class OutputPortInfo;
class OutputPortInfoDefaultTypeInternal;
extern OutputPortInfoDefaultTypeInternal _OutputPortInfo_default_instance_;
class PortInfoReply;
class PortInfoReplyDefaultTypeInternal;
extern PortInfoReplyDefaultTypeInternal _PortInfoReply_default_instance_;
class PreviewModeRequest;
class PreviewModeRequestDefaultTypeInternal;
extern PreviewModeRequestDefaultTypeInternal _PreviewModeRequest_default_instance_;
class Reply;
class ReplyDefaultTypeInternal;
extern ReplyDefaultTypeInternal _Reply_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class SourceEntry;
class SourceEntryDefaultTypeInternal;
extern SourceEntryDefaultTypeInternal _SourceEntry_default_instance_;
class SourceListReply;
class SourceListReplyDefaultTypeInternal;
extern SourceListReplyDefaultTypeInternal _SourceListReply_default_instance_;
class SourceListRequest;
class SourceListRequestDefaultTypeInternal;
extern SourceListRequestDefaultTypeInternal _SourceListRequest_default_instance_;
}  // namespace e131
}  // namespace plugin
}  // namespace ola
PROTOBUF_NAMESPACE_OPEN
template<> ::ola::plugin::e131::InputPortInfo* Arena::CreateMaybeMessage<::ola::plugin::e131::InputPortInfo>(Arena*);
template<> ::ola::plugin::e131::OutputPortInfo* Arena::CreateMaybeMessage<::ola::plugin::e131::OutputPortInfo>(Arena*);
template<> ::ola::plugin::e131::PortInfoReply* Arena::CreateMaybeMessage<::ola::plugin::e131::PortInfoReply>(Arena*);
template<> ::ola::plugin::e131::PreviewModeRequest* Arena::CreateMaybeMessage<::ola::plugin::e131::PreviewModeRequest>(Arena*);
template<> ::ola::plugin::e131::Reply* Arena::CreateMaybeMessage<::ola::plugin::e131::Reply>(Arena*);
template<> ::ola::plugin::e131::Request* Arena::CreateMaybeMessage<::ola::plugin::e131::Request>(Arena*);
template<> ::ola::plugin::e131::SourceEntry* Arena::CreateMaybeMessage<::ola::plugin::e131::SourceEntry>(Arena*);
template<> ::ola::plugin::e131::SourceListReply* Arena::CreateMaybeMessage<::ola::plugin::e131::SourceListReply>(Arena*);
template<> ::ola::plugin::e131::SourceListRequest* Arena::CreateMaybeMessage<::ola::plugin::e131::SourceListRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ola {
namespace plugin {
namespace e131 {

enum Request_RequestType : int {
  Request_RequestType_E131_PORT_INFO = 1,
  Request_RequestType_E131_PREVIEW_MODE = 2,
  Request_RequestType_E131_SOURCES_LIST = 3
};
bool Request_RequestType_IsValid(int value);
constexpr Request_RequestType Request_RequestType_RequestType_MIN = Request_RequestType_E131_PORT_INFO;
constexpr Request_RequestType Request_RequestType_RequestType_MAX = Request_RequestType_E131_SOURCES_LIST;
constexpr int Request_RequestType_RequestType_ARRAYSIZE = Request_RequestType_RequestType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Request_RequestType_descriptor();
template<typename T>
inline const std::string& Request_RequestType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Request_RequestType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Request_RequestType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Request_RequestType_descriptor(), enum_t_value);
}
inline bool Request_RequestType_Parse(
    const std::string& name, Request_RequestType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Request_RequestType>(
    Request_RequestType_descriptor(), name, value);
}
enum Reply_ReplyType : int {
  Reply_ReplyType_E131_PORT_INFO = 1,
  Reply_ReplyType_E131_SOURCES_LIST = 2
};
bool Reply_ReplyType_IsValid(int value);
constexpr Reply_ReplyType Reply_ReplyType_ReplyType_MIN = Reply_ReplyType_E131_PORT_INFO;
constexpr Reply_ReplyType Reply_ReplyType_ReplyType_MAX = Reply_ReplyType_E131_SOURCES_LIST;
constexpr int Reply_ReplyType_ReplyType_ARRAYSIZE = Reply_ReplyType_ReplyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Reply_ReplyType_descriptor();
template<typename T>
inline const std::string& Reply_ReplyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Reply_ReplyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Reply_ReplyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Reply_ReplyType_descriptor(), enum_t_value);
}
inline bool Reply_ReplyType_Parse(
    const std::string& name, Reply_ReplyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Reply_ReplyType>(
    Reply_ReplyType_descriptor(), name, value);
}
// ===================================================================

class PreviewModeRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ola.plugin.e131.PreviewModeRequest) */ {
 public:
  inline PreviewModeRequest() : PreviewModeRequest(nullptr) {};
  virtual ~PreviewModeRequest();

  PreviewModeRequest(const PreviewModeRequest& from);
  PreviewModeRequest(PreviewModeRequest&& from) noexcept
    : PreviewModeRequest() {
    *this = ::std::move(from);
  }

  inline PreviewModeRequest& operator=(const PreviewModeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PreviewModeRequest& operator=(PreviewModeRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PreviewModeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PreviewModeRequest* internal_default_instance() {
    return reinterpret_cast<const PreviewModeRequest*>(
               &_PreviewModeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PreviewModeRequest& a, PreviewModeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PreviewModeRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PreviewModeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PreviewModeRequest* New() const final {
    return CreateMaybeMessage<PreviewModeRequest>(nullptr);
  }

  PreviewModeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PreviewModeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PreviewModeRequest& from);
  void MergeFrom(const PreviewModeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PreviewModeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ola.plugin.e131.PreviewModeRequest";
  }
  protected:
  explicit PreviewModeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_E131ConfigMessages_2eproto);
    return ::descriptor_table_E131ConfigMessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortIdFieldNumber = 1,
    kPreviewModeFieldNumber = 2,
    kInputPortFieldNumber = 3,
  };
  // required int32 port_id = 1;
  bool has_port_id() const;
  private:
  bool _internal_has_port_id() const;
  public:
  void clear_port_id();
  ::PROTOBUF_NAMESPACE_ID::int32 port_id() const;
  void set_port_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port_id() const;
  void _internal_set_port_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required bool preview_mode = 2;
  bool has_preview_mode() const;
  private:
  bool _internal_has_preview_mode() const;
  public:
  void clear_preview_mode();
  bool preview_mode() const;
  void set_preview_mode(bool value);
  private:
  bool _internal_preview_mode() const;
  void _internal_set_preview_mode(bool value);
  public:

  // required bool input_port = 3;
  bool has_input_port() const;
  private:
  bool _internal_has_input_port() const;
  public:
  void clear_input_port();
  bool input_port() const;
  void set_input_port(bool value);
  private:
  bool _internal_input_port() const;
  void _internal_set_input_port(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ola.plugin.e131.PreviewModeRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_id_;
  bool preview_mode_;
  bool input_port_;
  friend struct ::TableStruct_E131ConfigMessages_2eproto;
};
// -------------------------------------------------------------------

class InputPortInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ola.plugin.e131.InputPortInfo) */ {
 public:
  inline InputPortInfo() : InputPortInfo(nullptr) {};
  virtual ~InputPortInfo();

  InputPortInfo(const InputPortInfo& from);
  InputPortInfo(InputPortInfo&& from) noexcept
    : InputPortInfo() {
    *this = ::std::move(from);
  }

  inline InputPortInfo& operator=(const InputPortInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputPortInfo& operator=(InputPortInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InputPortInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InputPortInfo* internal_default_instance() {
    return reinterpret_cast<const InputPortInfo*>(
               &_InputPortInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(InputPortInfo& a, InputPortInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(InputPortInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputPortInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InputPortInfo* New() const final {
    return CreateMaybeMessage<InputPortInfo>(nullptr);
  }

  InputPortInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InputPortInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InputPortInfo& from);
  void MergeFrom(const InputPortInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputPortInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ola.plugin.e131.InputPortInfo";
  }
  protected:
  explicit InputPortInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_E131ConfigMessages_2eproto);
    return ::descriptor_table_E131ConfigMessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortIdFieldNumber = 1,
    kPreviewModeFieldNumber = 2,
  };
  // required int32 port_id = 1;
  bool has_port_id() const;
  private:
  bool _internal_has_port_id() const;
  public:
  void clear_port_id();
  ::PROTOBUF_NAMESPACE_ID::int32 port_id() const;
  void set_port_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port_id() const;
  void _internal_set_port_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required bool preview_mode = 2;
  bool has_preview_mode() const;
  private:
  bool _internal_has_preview_mode() const;
  public:
  void clear_preview_mode();
  bool preview_mode() const;
  void set_preview_mode(bool value);
  private:
  bool _internal_preview_mode() const;
  void _internal_set_preview_mode(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ola.plugin.e131.InputPortInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_id_;
  bool preview_mode_;
  friend struct ::TableStruct_E131ConfigMessages_2eproto;
};
// -------------------------------------------------------------------

class OutputPortInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ola.plugin.e131.OutputPortInfo) */ {
 public:
  inline OutputPortInfo() : OutputPortInfo(nullptr) {};
  virtual ~OutputPortInfo();

  OutputPortInfo(const OutputPortInfo& from);
  OutputPortInfo(OutputPortInfo&& from) noexcept
    : OutputPortInfo() {
    *this = ::std::move(from);
  }

  inline OutputPortInfo& operator=(const OutputPortInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutputPortInfo& operator=(OutputPortInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OutputPortInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OutputPortInfo* internal_default_instance() {
    return reinterpret_cast<const OutputPortInfo*>(
               &_OutputPortInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OutputPortInfo& a, OutputPortInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OutputPortInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutputPortInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OutputPortInfo* New() const final {
    return CreateMaybeMessage<OutputPortInfo>(nullptr);
  }

  OutputPortInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OutputPortInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OutputPortInfo& from);
  void MergeFrom(const OutputPortInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutputPortInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ola.plugin.e131.OutputPortInfo";
  }
  protected:
  explicit OutputPortInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_E131ConfigMessages_2eproto);
    return ::descriptor_table_E131ConfigMessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortIdFieldNumber = 1,
    kPreviewModeFieldNumber = 2,
  };
  // required int32 port_id = 1;
  bool has_port_id() const;
  private:
  bool _internal_has_port_id() const;
  public:
  void clear_port_id();
  ::PROTOBUF_NAMESPACE_ID::int32 port_id() const;
  void set_port_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port_id() const;
  void _internal_set_port_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required bool preview_mode = 2;
  bool has_preview_mode() const;
  private:
  bool _internal_has_preview_mode() const;
  public:
  void clear_preview_mode();
  bool preview_mode() const;
  void set_preview_mode(bool value);
  private:
  bool _internal_preview_mode() const;
  void _internal_set_preview_mode(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ola.plugin.e131.OutputPortInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_id_;
  bool preview_mode_;
  friend struct ::TableStruct_E131ConfigMessages_2eproto;
};
// -------------------------------------------------------------------

class PortInfoReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ola.plugin.e131.PortInfoReply) */ {
 public:
  inline PortInfoReply() : PortInfoReply(nullptr) {};
  virtual ~PortInfoReply();

  PortInfoReply(const PortInfoReply& from);
  PortInfoReply(PortInfoReply&& from) noexcept
    : PortInfoReply() {
    *this = ::std::move(from);
  }

  inline PortInfoReply& operator=(const PortInfoReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortInfoReply& operator=(PortInfoReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PortInfoReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PortInfoReply* internal_default_instance() {
    return reinterpret_cast<const PortInfoReply*>(
               &_PortInfoReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PortInfoReply& a, PortInfoReply& b) {
    a.Swap(&b);
  }
  inline void Swap(PortInfoReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortInfoReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PortInfoReply* New() const final {
    return CreateMaybeMessage<PortInfoReply>(nullptr);
  }

  PortInfoReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PortInfoReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PortInfoReply& from);
  void MergeFrom(const PortInfoReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortInfoReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ola.plugin.e131.PortInfoReply";
  }
  protected:
  explicit PortInfoReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_E131ConfigMessages_2eproto);
    return ::descriptor_table_E131ConfigMessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputPortFieldNumber = 1,
    kOutputPortFieldNumber = 2,
  };
  // repeated .ola.plugin.e131.InputPortInfo input_port = 1;
  int input_port_size() const;
  private:
  int _internal_input_port_size() const;
  public:
  void clear_input_port();
  ::ola::plugin::e131::InputPortInfo* mutable_input_port(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ola::plugin::e131::InputPortInfo >*
      mutable_input_port();
  private:
  const ::ola::plugin::e131::InputPortInfo& _internal_input_port(int index) const;
  ::ola::plugin::e131::InputPortInfo* _internal_add_input_port();
  public:
  const ::ola::plugin::e131::InputPortInfo& input_port(int index) const;
  ::ola::plugin::e131::InputPortInfo* add_input_port();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ola::plugin::e131::InputPortInfo >&
      input_port() const;

  // repeated .ola.plugin.e131.OutputPortInfo output_port = 2;
  int output_port_size() const;
  private:
  int _internal_output_port_size() const;
  public:
  void clear_output_port();
  ::ola::plugin::e131::OutputPortInfo* mutable_output_port(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ola::plugin::e131::OutputPortInfo >*
      mutable_output_port();
  private:
  const ::ola::plugin::e131::OutputPortInfo& _internal_output_port(int index) const;
  ::ola::plugin::e131::OutputPortInfo* _internal_add_output_port();
  public:
  const ::ola::plugin::e131::OutputPortInfo& output_port(int index) const;
  ::ola::plugin::e131::OutputPortInfo* add_output_port();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ola::plugin::e131::OutputPortInfo >&
      output_port() const;

  // @@protoc_insertion_point(class_scope:ola.plugin.e131.PortInfoReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ola::plugin::e131::InputPortInfo > input_port_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ola::plugin::e131::OutputPortInfo > output_port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_E131ConfigMessages_2eproto;
};
// -------------------------------------------------------------------

class SourceListRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ola.plugin.e131.SourceListRequest) */ {
 public:
  inline SourceListRequest() : SourceListRequest(nullptr) {};
  virtual ~SourceListRequest();

  SourceListRequest(const SourceListRequest& from);
  SourceListRequest(SourceListRequest&& from) noexcept
    : SourceListRequest() {
    *this = ::std::move(from);
  }

  inline SourceListRequest& operator=(const SourceListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SourceListRequest& operator=(SourceListRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SourceListRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SourceListRequest* internal_default_instance() {
    return reinterpret_cast<const SourceListRequest*>(
               &_SourceListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SourceListRequest& a, SourceListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SourceListRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SourceListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SourceListRequest* New() const final {
    return CreateMaybeMessage<SourceListRequest>(nullptr);
  }

  SourceListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SourceListRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SourceListRequest& from);
  void MergeFrom(const SourceListRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SourceListRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ola.plugin.e131.SourceListRequest";
  }
  protected:
  explicit SourceListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_E131ConfigMessages_2eproto);
    return ::descriptor_table_E131ConfigMessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ola.plugin.e131.SourceListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_E131ConfigMessages_2eproto;
};
// -------------------------------------------------------------------

class SourceEntry PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ola.plugin.e131.SourceEntry) */ {
 public:
  inline SourceEntry() : SourceEntry(nullptr) {};
  virtual ~SourceEntry();

  SourceEntry(const SourceEntry& from);
  SourceEntry(SourceEntry&& from) noexcept
    : SourceEntry() {
    *this = ::std::move(from);
  }

  inline SourceEntry& operator=(const SourceEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline SourceEntry& operator=(SourceEntry&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SourceEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SourceEntry* internal_default_instance() {
    return reinterpret_cast<const SourceEntry*>(
               &_SourceEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SourceEntry& a, SourceEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(SourceEntry* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SourceEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SourceEntry* New() const final {
    return CreateMaybeMessage<SourceEntry>(nullptr);
  }

  SourceEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SourceEntry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SourceEntry& from);
  void MergeFrom(const SourceEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SourceEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ola.plugin.e131.SourceEntry";
  }
  protected:
  explicit SourceEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_E131ConfigMessages_2eproto);
    return ::descriptor_table_E131ConfigMessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUniverseFieldNumber = 4,
    kCidFieldNumber = 1,
    kIpAddressFieldNumber = 2,
    kSourceNameFieldNumber = 3,
  };
  // repeated int32 universe = 4;
  int universe_size() const;
  private:
  int _internal_universe_size() const;
  public:
  void clear_universe();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_universe(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_universe() const;
  void _internal_add_universe(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_universe();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 universe(int index) const;
  void set_universe(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_universe(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      universe() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_universe();

  // required string cid = 1;
  bool has_cid() const;
  private:
  bool _internal_has_cid() const;
  public:
  void clear_cid();
  const std::string& cid() const;
  void set_cid(const std::string& value);
  void set_cid(std::string&& value);
  void set_cid(const char* value);
  void set_cid(const char* value, size_t size);
  std::string* mutable_cid();
  std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_cid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_cid(
      std::string* cid);
  private:
  const std::string& _internal_cid() const;
  void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // required string ip_address = 2;
  bool has_ip_address() const;
  private:
  bool _internal_has_ip_address() const;
  public:
  void clear_ip_address();
  const std::string& ip_address() const;
  void set_ip_address(const std::string& value);
  void set_ip_address(std::string&& value);
  void set_ip_address(const char* value);
  void set_ip_address(const char* value, size_t size);
  std::string* mutable_ip_address();
  std::string* release_ip_address();
  void set_allocated_ip_address(std::string* ip_address);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ip_address();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ip_address(
      std::string* ip_address);
  private:
  const std::string& _internal_ip_address() const;
  void _internal_set_ip_address(const std::string& value);
  std::string* _internal_mutable_ip_address();
  public:

  // optional string source_name = 3;
  bool has_source_name() const;
  private:
  bool _internal_has_source_name() const;
  public:
  void clear_source_name();
  const std::string& source_name() const;
  void set_source_name(const std::string& value);
  void set_source_name(std::string&& value);
  void set_source_name(const char* value);
  void set_source_name(const char* value, size_t size);
  std::string* mutable_source_name();
  std::string* release_source_name();
  void set_allocated_source_name(std::string* source_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_source_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_source_name(
      std::string* source_name);
  private:
  const std::string& _internal_source_name() const;
  void _internal_set_source_name(const std::string& value);
  std::string* _internal_mutable_source_name();
  public:

  // @@protoc_insertion_point(class_scope:ola.plugin.e131.SourceEntry)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > universe_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_name_;
  friend struct ::TableStruct_E131ConfigMessages_2eproto;
};
// -------------------------------------------------------------------

class SourceListReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ola.plugin.e131.SourceListReply) */ {
 public:
  inline SourceListReply() : SourceListReply(nullptr) {};
  virtual ~SourceListReply();

  SourceListReply(const SourceListReply& from);
  SourceListReply(SourceListReply&& from) noexcept
    : SourceListReply() {
    *this = ::std::move(from);
  }

  inline SourceListReply& operator=(const SourceListReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SourceListReply& operator=(SourceListReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SourceListReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SourceListReply* internal_default_instance() {
    return reinterpret_cast<const SourceListReply*>(
               &_SourceListReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SourceListReply& a, SourceListReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SourceListReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SourceListReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SourceListReply* New() const final {
    return CreateMaybeMessage<SourceListReply>(nullptr);
  }

  SourceListReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SourceListReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SourceListReply& from);
  void MergeFrom(const SourceListReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SourceListReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ola.plugin.e131.SourceListReply";
  }
  protected:
  explicit SourceListReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_E131ConfigMessages_2eproto);
    return ::descriptor_table_E131ConfigMessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceFieldNumber = 2,
    kUnsupportedFieldNumber = 1,
  };
  // repeated .ola.plugin.e131.SourceEntry source = 2;
  int source_size() const;
  private:
  int _internal_source_size() const;
  public:
  void clear_source();
  ::ola::plugin::e131::SourceEntry* mutable_source(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ola::plugin::e131::SourceEntry >*
      mutable_source();
  private:
  const ::ola::plugin::e131::SourceEntry& _internal_source(int index) const;
  ::ola::plugin::e131::SourceEntry* _internal_add_source();
  public:
  const ::ola::plugin::e131::SourceEntry& source(int index) const;
  ::ola::plugin::e131::SourceEntry* add_source();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ola::plugin::e131::SourceEntry >&
      source() const;

  // optional bool unsupported = 1 [default = true];
  bool has_unsupported() const;
  private:
  bool _internal_has_unsupported() const;
  public:
  void clear_unsupported();
  bool unsupported() const;
  void set_unsupported(bool value);
  private:
  bool _internal_unsupported() const;
  void _internal_set_unsupported(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ola.plugin.e131.SourceListReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ola::plugin::e131::SourceEntry > source_;
  bool unsupported_;
  friend struct ::TableStruct_E131ConfigMessages_2eproto;
};
// -------------------------------------------------------------------

class Request PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ola.plugin.e131.Request) */ {
 public:
  inline Request() : Request(nullptr) {};
  virtual ~Request();

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Request& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const final {
    return CreateMaybeMessage<Request>(nullptr);
  }

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ola.plugin.e131.Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_E131ConfigMessages_2eproto);
    return ::descriptor_table_E131ConfigMessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Request_RequestType RequestType;
  static constexpr RequestType E131_PORT_INFO =
    Request_RequestType_E131_PORT_INFO;
  static constexpr RequestType E131_PREVIEW_MODE =
    Request_RequestType_E131_PREVIEW_MODE;
  static constexpr RequestType E131_SOURCES_LIST =
    Request_RequestType_E131_SOURCES_LIST;
  static inline bool RequestType_IsValid(int value) {
    return Request_RequestType_IsValid(value);
  }
  static constexpr RequestType RequestType_MIN =
    Request_RequestType_RequestType_MIN;
  static constexpr RequestType RequestType_MAX =
    Request_RequestType_RequestType_MAX;
  static constexpr int RequestType_ARRAYSIZE =
    Request_RequestType_RequestType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RequestType_descriptor() {
    return Request_RequestType_descriptor();
  }
  template<typename T>
  static inline const std::string& RequestType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RequestType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RequestType_Name.");
    return Request_RequestType_Name(enum_t_value);
  }
  static inline bool RequestType_Parse(const std::string& name,
      RequestType* value) {
    return Request_RequestType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPreviewModeFieldNumber = 2,
    kSourceListFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // optional .ola.plugin.e131.PreviewModeRequest preview_mode = 2;
  bool has_preview_mode() const;
  private:
  bool _internal_has_preview_mode() const;
  public:
  void clear_preview_mode();
  const ::ola::plugin::e131::PreviewModeRequest& preview_mode() const;
  ::ola::plugin::e131::PreviewModeRequest* release_preview_mode();
  ::ola::plugin::e131::PreviewModeRequest* mutable_preview_mode();
  void set_allocated_preview_mode(::ola::plugin::e131::PreviewModeRequest* preview_mode);
  private:
  const ::ola::plugin::e131::PreviewModeRequest& _internal_preview_mode() const;
  ::ola::plugin::e131::PreviewModeRequest* _internal_mutable_preview_mode();
  public:
  void unsafe_arena_set_allocated_preview_mode(
      ::ola::plugin::e131::PreviewModeRequest* preview_mode);
  ::ola::plugin::e131::PreviewModeRequest* unsafe_arena_release_preview_mode();

  // optional .ola.plugin.e131.SourceListRequest source_list = 3;
  bool has_source_list() const;
  private:
  bool _internal_has_source_list() const;
  public:
  void clear_source_list();
  const ::ola::plugin::e131::SourceListRequest& source_list() const;
  ::ola::plugin::e131::SourceListRequest* release_source_list();
  ::ola::plugin::e131::SourceListRequest* mutable_source_list();
  void set_allocated_source_list(::ola::plugin::e131::SourceListRequest* source_list);
  private:
  const ::ola::plugin::e131::SourceListRequest& _internal_source_list() const;
  ::ola::plugin::e131::SourceListRequest* _internal_mutable_source_list();
  public:
  void unsafe_arena_set_allocated_source_list(
      ::ola::plugin::e131::SourceListRequest* source_list);
  ::ola::plugin::e131::SourceListRequest* unsafe_arena_release_source_list();

  // required .ola.plugin.e131.Request.RequestType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::ola::plugin::e131::Request_RequestType type() const;
  void set_type(::ola::plugin::e131::Request_RequestType value);
  private:
  ::ola::plugin::e131::Request_RequestType _internal_type() const;
  void _internal_set_type(::ola::plugin::e131::Request_RequestType value);
  public:

  // @@protoc_insertion_point(class_scope:ola.plugin.e131.Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ola::plugin::e131::PreviewModeRequest* preview_mode_;
  ::ola::plugin::e131::SourceListRequest* source_list_;
  int type_;
  friend struct ::TableStruct_E131ConfigMessages_2eproto;
};
// -------------------------------------------------------------------

class Reply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ola.plugin.e131.Reply) */ {
 public:
  inline Reply() : Reply(nullptr) {};
  virtual ~Reply();

  Reply(const Reply& from);
  Reply(Reply&& from) noexcept
    : Reply() {
    *this = ::std::move(from);
  }

  inline Reply& operator=(const Reply& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reply& operator=(Reply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Reply* internal_default_instance() {
    return reinterpret_cast<const Reply*>(
               &_Reply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Reply& a, Reply& b) {
    a.Swap(&b);
  }
  inline void Swap(Reply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Reply* New() const final {
    return CreateMaybeMessage<Reply>(nullptr);
  }

  Reply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Reply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Reply& from);
  void MergeFrom(const Reply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ola.plugin.e131.Reply";
  }
  protected:
  explicit Reply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_E131ConfigMessages_2eproto);
    return ::descriptor_table_E131ConfigMessages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Reply_ReplyType ReplyType;
  static constexpr ReplyType E131_PORT_INFO =
    Reply_ReplyType_E131_PORT_INFO;
  static constexpr ReplyType E131_SOURCES_LIST =
    Reply_ReplyType_E131_SOURCES_LIST;
  static inline bool ReplyType_IsValid(int value) {
    return Reply_ReplyType_IsValid(value);
  }
  static constexpr ReplyType ReplyType_MIN =
    Reply_ReplyType_ReplyType_MIN;
  static constexpr ReplyType ReplyType_MAX =
    Reply_ReplyType_ReplyType_MAX;
  static constexpr int ReplyType_ARRAYSIZE =
    Reply_ReplyType_ReplyType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ReplyType_descriptor() {
    return Reply_ReplyType_descriptor();
  }
  template<typename T>
  static inline const std::string& ReplyType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ReplyType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ReplyType_Name.");
    return Reply_ReplyType_Name(enum_t_value);
  }
  static inline bool ReplyType_Parse(const std::string& name,
      ReplyType* value) {
    return Reply_ReplyType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPortInfoFieldNumber = 2,
    kSourceListFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // optional .ola.plugin.e131.PortInfoReply port_info = 2;
  bool has_port_info() const;
  private:
  bool _internal_has_port_info() const;
  public:
  void clear_port_info();
  const ::ola::plugin::e131::PortInfoReply& port_info() const;
  ::ola::plugin::e131::PortInfoReply* release_port_info();
  ::ola::plugin::e131::PortInfoReply* mutable_port_info();
  void set_allocated_port_info(::ola::plugin::e131::PortInfoReply* port_info);
  private:
  const ::ola::plugin::e131::PortInfoReply& _internal_port_info() const;
  ::ola::plugin::e131::PortInfoReply* _internal_mutable_port_info();
  public:
  void unsafe_arena_set_allocated_port_info(
      ::ola::plugin::e131::PortInfoReply* port_info);
  ::ola::plugin::e131::PortInfoReply* unsafe_arena_release_port_info();

  // optional .ola.plugin.e131.SourceListReply source_list = 3;
  bool has_source_list() const;
  private:
  bool _internal_has_source_list() const;
  public:
  void clear_source_list();
  const ::ola::plugin::e131::SourceListReply& source_list() const;
  ::ola::plugin::e131::SourceListReply* release_source_list();
  ::ola::plugin::e131::SourceListReply* mutable_source_list();
  void set_allocated_source_list(::ola::plugin::e131::SourceListReply* source_list);
  private:
  const ::ola::plugin::e131::SourceListReply& _internal_source_list() const;
  ::ola::plugin::e131::SourceListReply* _internal_mutable_source_list();
  public:
  void unsafe_arena_set_allocated_source_list(
      ::ola::plugin::e131::SourceListReply* source_list);
  ::ola::plugin::e131::SourceListReply* unsafe_arena_release_source_list();

  // required .ola.plugin.e131.Reply.ReplyType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::ola::plugin::e131::Reply_ReplyType type() const;
  void set_type(::ola::plugin::e131::Reply_ReplyType value);
  private:
  ::ola::plugin::e131::Reply_ReplyType _internal_type() const;
  void _internal_set_type(::ola::plugin::e131::Reply_ReplyType value);
  public:

  // @@protoc_insertion_point(class_scope:ola.plugin.e131.Reply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ola::plugin::e131::PortInfoReply* port_info_;
  ::ola::plugin::e131::SourceListReply* source_list_;
  int type_;
  friend struct ::TableStruct_E131ConfigMessages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PreviewModeRequest

// required int32 port_id = 1;
inline bool PreviewModeRequest::_internal_has_port_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PreviewModeRequest::has_port_id() const {
  return _internal_has_port_id();
}
inline void PreviewModeRequest::clear_port_id() {
  port_id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PreviewModeRequest::_internal_port_id() const {
  return port_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PreviewModeRequest::port_id() const {
  // @@protoc_insertion_point(field_get:ola.plugin.e131.PreviewModeRequest.port_id)
  return _internal_port_id();
}
inline void PreviewModeRequest::_internal_set_port_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  port_id_ = value;
}
inline void PreviewModeRequest::set_port_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port_id(value);
  // @@protoc_insertion_point(field_set:ola.plugin.e131.PreviewModeRequest.port_id)
}

// required bool preview_mode = 2;
inline bool PreviewModeRequest::_internal_has_preview_mode() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PreviewModeRequest::has_preview_mode() const {
  return _internal_has_preview_mode();
}
inline void PreviewModeRequest::clear_preview_mode() {
  preview_mode_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool PreviewModeRequest::_internal_preview_mode() const {
  return preview_mode_;
}
inline bool PreviewModeRequest::preview_mode() const {
  // @@protoc_insertion_point(field_get:ola.plugin.e131.PreviewModeRequest.preview_mode)
  return _internal_preview_mode();
}
inline void PreviewModeRequest::_internal_set_preview_mode(bool value) {
  _has_bits_[0] |= 0x00000002u;
  preview_mode_ = value;
}
inline void PreviewModeRequest::set_preview_mode(bool value) {
  _internal_set_preview_mode(value);
  // @@protoc_insertion_point(field_set:ola.plugin.e131.PreviewModeRequest.preview_mode)
}

// required bool input_port = 3;
inline bool PreviewModeRequest::_internal_has_input_port() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PreviewModeRequest::has_input_port() const {
  return _internal_has_input_port();
}
inline void PreviewModeRequest::clear_input_port() {
  input_port_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool PreviewModeRequest::_internal_input_port() const {
  return input_port_;
}
inline bool PreviewModeRequest::input_port() const {
  // @@protoc_insertion_point(field_get:ola.plugin.e131.PreviewModeRequest.input_port)
  return _internal_input_port();
}
inline void PreviewModeRequest::_internal_set_input_port(bool value) {
  _has_bits_[0] |= 0x00000004u;
  input_port_ = value;
}
inline void PreviewModeRequest::set_input_port(bool value) {
  _internal_set_input_port(value);
  // @@protoc_insertion_point(field_set:ola.plugin.e131.PreviewModeRequest.input_port)
}

// -------------------------------------------------------------------

// InputPortInfo

// required int32 port_id = 1;
inline bool InputPortInfo::_internal_has_port_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InputPortInfo::has_port_id() const {
  return _internal_has_port_id();
}
inline void InputPortInfo::clear_port_id() {
  port_id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InputPortInfo::_internal_port_id() const {
  return port_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InputPortInfo::port_id() const {
  // @@protoc_insertion_point(field_get:ola.plugin.e131.InputPortInfo.port_id)
  return _internal_port_id();
}
inline void InputPortInfo::_internal_set_port_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  port_id_ = value;
}
inline void InputPortInfo::set_port_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port_id(value);
  // @@protoc_insertion_point(field_set:ola.plugin.e131.InputPortInfo.port_id)
}

// required bool preview_mode = 2;
inline bool InputPortInfo::_internal_has_preview_mode() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InputPortInfo::has_preview_mode() const {
  return _internal_has_preview_mode();
}
inline void InputPortInfo::clear_preview_mode() {
  preview_mode_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool InputPortInfo::_internal_preview_mode() const {
  return preview_mode_;
}
inline bool InputPortInfo::preview_mode() const {
  // @@protoc_insertion_point(field_get:ola.plugin.e131.InputPortInfo.preview_mode)
  return _internal_preview_mode();
}
inline void InputPortInfo::_internal_set_preview_mode(bool value) {
  _has_bits_[0] |= 0x00000002u;
  preview_mode_ = value;
}
inline void InputPortInfo::set_preview_mode(bool value) {
  _internal_set_preview_mode(value);
  // @@protoc_insertion_point(field_set:ola.plugin.e131.InputPortInfo.preview_mode)
}

// -------------------------------------------------------------------

// OutputPortInfo

// required int32 port_id = 1;
inline bool OutputPortInfo::_internal_has_port_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OutputPortInfo::has_port_id() const {
  return _internal_has_port_id();
}
inline void OutputPortInfo::clear_port_id() {
  port_id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OutputPortInfo::_internal_port_id() const {
  return port_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OutputPortInfo::port_id() const {
  // @@protoc_insertion_point(field_get:ola.plugin.e131.OutputPortInfo.port_id)
  return _internal_port_id();
}
inline void OutputPortInfo::_internal_set_port_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  port_id_ = value;
}
inline void OutputPortInfo::set_port_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port_id(value);
  // @@protoc_insertion_point(field_set:ola.plugin.e131.OutputPortInfo.port_id)
}

// required bool preview_mode = 2;
inline bool OutputPortInfo::_internal_has_preview_mode() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OutputPortInfo::has_preview_mode() const {
  return _internal_has_preview_mode();
}
inline void OutputPortInfo::clear_preview_mode() {
  preview_mode_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool OutputPortInfo::_internal_preview_mode() const {
  return preview_mode_;
}
inline bool OutputPortInfo::preview_mode() const {
  // @@protoc_insertion_point(field_get:ola.plugin.e131.OutputPortInfo.preview_mode)
  return _internal_preview_mode();
}
inline void OutputPortInfo::_internal_set_preview_mode(bool value) {
  _has_bits_[0] |= 0x00000002u;
  preview_mode_ = value;
}
inline void OutputPortInfo::set_preview_mode(bool value) {
  _internal_set_preview_mode(value);
  // @@protoc_insertion_point(field_set:ola.plugin.e131.OutputPortInfo.preview_mode)
}

// -------------------------------------------------------------------

// PortInfoReply

// repeated .ola.plugin.e131.InputPortInfo input_port = 1;
inline int PortInfoReply::_internal_input_port_size() const {
  return input_port_.size();
}
inline int PortInfoReply::input_port_size() const {
  return _internal_input_port_size();
}
inline void PortInfoReply::clear_input_port() {
  input_port_.Clear();
}
inline ::ola::plugin::e131::InputPortInfo* PortInfoReply::mutable_input_port(int index) {
  // @@protoc_insertion_point(field_mutable:ola.plugin.e131.PortInfoReply.input_port)
  return input_port_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ola::plugin::e131::InputPortInfo >*
PortInfoReply::mutable_input_port() {
  // @@protoc_insertion_point(field_mutable_list:ola.plugin.e131.PortInfoReply.input_port)
  return &input_port_;
}
inline const ::ola::plugin::e131::InputPortInfo& PortInfoReply::_internal_input_port(int index) const {
  return input_port_.Get(index);
}
inline const ::ola::plugin::e131::InputPortInfo& PortInfoReply::input_port(int index) const {
  // @@protoc_insertion_point(field_get:ola.plugin.e131.PortInfoReply.input_port)
  return _internal_input_port(index);
}
inline ::ola::plugin::e131::InputPortInfo* PortInfoReply::_internal_add_input_port() {
  return input_port_.Add();
}
inline ::ola::plugin::e131::InputPortInfo* PortInfoReply::add_input_port() {
  // @@protoc_insertion_point(field_add:ola.plugin.e131.PortInfoReply.input_port)
  return _internal_add_input_port();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ola::plugin::e131::InputPortInfo >&
PortInfoReply::input_port() const {
  // @@protoc_insertion_point(field_list:ola.plugin.e131.PortInfoReply.input_port)
  return input_port_;
}

// repeated .ola.plugin.e131.OutputPortInfo output_port = 2;
inline int PortInfoReply::_internal_output_port_size() const {
  return output_port_.size();
}
inline int PortInfoReply::output_port_size() const {
  return _internal_output_port_size();
}
inline void PortInfoReply::clear_output_port() {
  output_port_.Clear();
}
inline ::ola::plugin::e131::OutputPortInfo* PortInfoReply::mutable_output_port(int index) {
  // @@protoc_insertion_point(field_mutable:ola.plugin.e131.PortInfoReply.output_port)
  return output_port_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ola::plugin::e131::OutputPortInfo >*
PortInfoReply::mutable_output_port() {
  // @@protoc_insertion_point(field_mutable_list:ola.plugin.e131.PortInfoReply.output_port)
  return &output_port_;
}
inline const ::ola::plugin::e131::OutputPortInfo& PortInfoReply::_internal_output_port(int index) const {
  return output_port_.Get(index);
}
inline const ::ola::plugin::e131::OutputPortInfo& PortInfoReply::output_port(int index) const {
  // @@protoc_insertion_point(field_get:ola.plugin.e131.PortInfoReply.output_port)
  return _internal_output_port(index);
}
inline ::ola::plugin::e131::OutputPortInfo* PortInfoReply::_internal_add_output_port() {
  return output_port_.Add();
}
inline ::ola::plugin::e131::OutputPortInfo* PortInfoReply::add_output_port() {
  // @@protoc_insertion_point(field_add:ola.plugin.e131.PortInfoReply.output_port)
  return _internal_add_output_port();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ola::plugin::e131::OutputPortInfo >&
PortInfoReply::output_port() const {
  // @@protoc_insertion_point(field_list:ola.plugin.e131.PortInfoReply.output_port)
  return output_port_;
}

// -------------------------------------------------------------------

// SourceListRequest

// -------------------------------------------------------------------

// SourceEntry

// required string cid = 1;
inline bool SourceEntry::_internal_has_cid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SourceEntry::has_cid() const {
  return _internal_has_cid();
}
inline void SourceEntry::clear_cid() {
  cid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SourceEntry::cid() const {
  // @@protoc_insertion_point(field_get:ola.plugin.e131.SourceEntry.cid)
  return _internal_cid();
}
inline void SourceEntry::set_cid(const std::string& value) {
  _internal_set_cid(value);
  // @@protoc_insertion_point(field_set:ola.plugin.e131.SourceEntry.cid)
}
inline std::string* SourceEntry::mutable_cid() {
  // @@protoc_insertion_point(field_mutable:ola.plugin.e131.SourceEntry.cid)
  return _internal_mutable_cid();
}
inline const std::string& SourceEntry::_internal_cid() const {
  return cid_.Get();
}
inline void SourceEntry::_internal_set_cid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  cid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SourceEntry::set_cid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  cid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ola.plugin.e131.SourceEntry.cid)
}
inline void SourceEntry::set_cid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  cid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ola.plugin.e131.SourceEntry.cid)
}
inline void SourceEntry::set_cid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  cid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ola.plugin.e131.SourceEntry.cid)
}
inline std::string* SourceEntry::_internal_mutable_cid() {
  _has_bits_[0] |= 0x00000001u;
  return cid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SourceEntry::release_cid() {
  // @@protoc_insertion_point(field_release:ola.plugin.e131.SourceEntry.cid)
  if (!_internal_has_cid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return cid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SourceEntry::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  cid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ola.plugin.e131.SourceEntry.cid)
}
inline std::string* SourceEntry::unsafe_arena_release_cid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ola.plugin.e131.SourceEntry.cid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return cid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SourceEntry::unsafe_arena_set_allocated_cid(
    std::string* cid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (cid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  cid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      cid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ola.plugin.e131.SourceEntry.cid)
}

// required string ip_address = 2;
inline bool SourceEntry::_internal_has_ip_address() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SourceEntry::has_ip_address() const {
  return _internal_has_ip_address();
}
inline void SourceEntry::clear_ip_address() {
  ip_address_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SourceEntry::ip_address() const {
  // @@protoc_insertion_point(field_get:ola.plugin.e131.SourceEntry.ip_address)
  return _internal_ip_address();
}
inline void SourceEntry::set_ip_address(const std::string& value) {
  _internal_set_ip_address(value);
  // @@protoc_insertion_point(field_set:ola.plugin.e131.SourceEntry.ip_address)
}
inline std::string* SourceEntry::mutable_ip_address() {
  // @@protoc_insertion_point(field_mutable:ola.plugin.e131.SourceEntry.ip_address)
  return _internal_mutable_ip_address();
}
inline const std::string& SourceEntry::_internal_ip_address() const {
  return ip_address_.Get();
}
inline void SourceEntry::_internal_set_ip_address(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SourceEntry::set_ip_address(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  ip_address_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ola.plugin.e131.SourceEntry.ip_address)
}
inline void SourceEntry::set_ip_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ola.plugin.e131.SourceEntry.ip_address)
}
inline void SourceEntry::set_ip_address(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ola.plugin.e131.SourceEntry.ip_address)
}
inline std::string* SourceEntry::_internal_mutable_ip_address() {
  _has_bits_[0] |= 0x00000002u;
  return ip_address_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SourceEntry::release_ip_address() {
  // @@protoc_insertion_point(field_release:ola.plugin.e131.SourceEntry.ip_address)
  if (!_internal_has_ip_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return ip_address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SourceEntry::set_allocated_ip_address(std::string* ip_address) {
  if (ip_address != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ip_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip_address,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ola.plugin.e131.SourceEntry.ip_address)
}
inline std::string* SourceEntry::unsafe_arena_release_ip_address() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ola.plugin.e131.SourceEntry.ip_address)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return ip_address_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SourceEntry::unsafe_arena_set_allocated_ip_address(
    std::string* ip_address) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ip_address != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ip_address_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ip_address, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ola.plugin.e131.SourceEntry.ip_address)
}

// optional string source_name = 3;
inline bool SourceEntry::_internal_has_source_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SourceEntry::has_source_name() const {
  return _internal_has_source_name();
}
inline void SourceEntry::clear_source_name() {
  source_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SourceEntry::source_name() const {
  // @@protoc_insertion_point(field_get:ola.plugin.e131.SourceEntry.source_name)
  return _internal_source_name();
}
inline void SourceEntry::set_source_name(const std::string& value) {
  _internal_set_source_name(value);
  // @@protoc_insertion_point(field_set:ola.plugin.e131.SourceEntry.source_name)
}
inline std::string* SourceEntry::mutable_source_name() {
  // @@protoc_insertion_point(field_mutable:ola.plugin.e131.SourceEntry.source_name)
  return _internal_mutable_source_name();
}
inline const std::string& SourceEntry::_internal_source_name() const {
  return source_name_.Get();
}
inline void SourceEntry::_internal_set_source_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  source_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SourceEntry::set_source_name(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  source_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ola.plugin.e131.SourceEntry.source_name)
}
inline void SourceEntry::set_source_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  source_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ola.plugin.e131.SourceEntry.source_name)
}
inline void SourceEntry::set_source_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  source_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ola.plugin.e131.SourceEntry.source_name)
}
inline std::string* SourceEntry::_internal_mutable_source_name() {
  _has_bits_[0] |= 0x00000004u;
  return source_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SourceEntry::release_source_name() {
  // @@protoc_insertion_point(field_release:ola.plugin.e131.SourceEntry.source_name)
  if (!_internal_has_source_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return source_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SourceEntry::set_allocated_source_name(std::string* source_name) {
  if (source_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  source_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), source_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ola.plugin.e131.SourceEntry.source_name)
}
inline std::string* SourceEntry::unsafe_arena_release_source_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ola.plugin.e131.SourceEntry.source_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return source_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SourceEntry::unsafe_arena_set_allocated_source_name(
    std::string* source_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (source_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  source_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      source_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ola.plugin.e131.SourceEntry.source_name)
}

// repeated int32 universe = 4;
inline int SourceEntry::_internal_universe_size() const {
  return universe_.size();
}
inline int SourceEntry::universe_size() const {
  return _internal_universe_size();
}
inline void SourceEntry::clear_universe() {
  universe_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SourceEntry::_internal_universe(int index) const {
  return universe_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SourceEntry::universe(int index) const {
  // @@protoc_insertion_point(field_get:ola.plugin.e131.SourceEntry.universe)
  return _internal_universe(index);
}
inline void SourceEntry::set_universe(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  universe_.Set(index, value);
  // @@protoc_insertion_point(field_set:ola.plugin.e131.SourceEntry.universe)
}
inline void SourceEntry::_internal_add_universe(::PROTOBUF_NAMESPACE_ID::int32 value) {
  universe_.Add(value);
}
inline void SourceEntry::add_universe(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_universe(value);
  // @@protoc_insertion_point(field_add:ola.plugin.e131.SourceEntry.universe)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
SourceEntry::_internal_universe() const {
  return universe_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
SourceEntry::universe() const {
  // @@protoc_insertion_point(field_list:ola.plugin.e131.SourceEntry.universe)
  return _internal_universe();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
SourceEntry::_internal_mutable_universe() {
  return &universe_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
SourceEntry::mutable_universe() {
  // @@protoc_insertion_point(field_mutable_list:ola.plugin.e131.SourceEntry.universe)
  return _internal_mutable_universe();
}

// -------------------------------------------------------------------

// SourceListReply

// optional bool unsupported = 1 [default = true];
inline bool SourceListReply::_internal_has_unsupported() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SourceListReply::has_unsupported() const {
  return _internal_has_unsupported();
}
inline void SourceListReply::clear_unsupported() {
  unsupported_ = true;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool SourceListReply::_internal_unsupported() const {
  return unsupported_;
}
inline bool SourceListReply::unsupported() const {
  // @@protoc_insertion_point(field_get:ola.plugin.e131.SourceListReply.unsupported)
  return _internal_unsupported();
}
inline void SourceListReply::_internal_set_unsupported(bool value) {
  _has_bits_[0] |= 0x00000001u;
  unsupported_ = value;
}
inline void SourceListReply::set_unsupported(bool value) {
  _internal_set_unsupported(value);
  // @@protoc_insertion_point(field_set:ola.plugin.e131.SourceListReply.unsupported)
}

// repeated .ola.plugin.e131.SourceEntry source = 2;
inline int SourceListReply::_internal_source_size() const {
  return source_.size();
}
inline int SourceListReply::source_size() const {
  return _internal_source_size();
}
inline void SourceListReply::clear_source() {
  source_.Clear();
}
inline ::ola::plugin::e131::SourceEntry* SourceListReply::mutable_source(int index) {
  // @@protoc_insertion_point(field_mutable:ola.plugin.e131.SourceListReply.source)
  return source_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ola::plugin::e131::SourceEntry >*
SourceListReply::mutable_source() {
  // @@protoc_insertion_point(field_mutable_list:ola.plugin.e131.SourceListReply.source)
  return &source_;
}
inline const ::ola::plugin::e131::SourceEntry& SourceListReply::_internal_source(int index) const {
  return source_.Get(index);
}
inline const ::ola::plugin::e131::SourceEntry& SourceListReply::source(int index) const {
  // @@protoc_insertion_point(field_get:ola.plugin.e131.SourceListReply.source)
  return _internal_source(index);
}
inline ::ola::plugin::e131::SourceEntry* SourceListReply::_internal_add_source() {
  return source_.Add();
}
inline ::ola::plugin::e131::SourceEntry* SourceListReply::add_source() {
  // @@protoc_insertion_point(field_add:ola.plugin.e131.SourceListReply.source)
  return _internal_add_source();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ola::plugin::e131::SourceEntry >&
SourceListReply::source() const {
  // @@protoc_insertion_point(field_list:ola.plugin.e131.SourceListReply.source)
  return source_;
}

// -------------------------------------------------------------------

// Request

// required .ola.plugin.e131.Request.RequestType type = 1;
inline bool Request::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Request::has_type() const {
  return _internal_has_type();
}
inline void Request::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::ola::plugin::e131::Request_RequestType Request::_internal_type() const {
  return static_cast< ::ola::plugin::e131::Request_RequestType >(type_);
}
inline ::ola::plugin::e131::Request_RequestType Request::type() const {
  // @@protoc_insertion_point(field_get:ola.plugin.e131.Request.type)
  return _internal_type();
}
inline void Request::_internal_set_type(::ola::plugin::e131::Request_RequestType value) {
  assert(::ola::plugin::e131::Request_RequestType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void Request::set_type(::ola::plugin::e131::Request_RequestType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ola.plugin.e131.Request.type)
}

// optional .ola.plugin.e131.PreviewModeRequest preview_mode = 2;
inline bool Request::_internal_has_preview_mode() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || preview_mode_ != nullptr);
  return value;
}
inline bool Request::has_preview_mode() const {
  return _internal_has_preview_mode();
}
inline void Request::clear_preview_mode() {
  if (preview_mode_ != nullptr) preview_mode_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ola::plugin::e131::PreviewModeRequest& Request::_internal_preview_mode() const {
  const ::ola::plugin::e131::PreviewModeRequest* p = preview_mode_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ola::plugin::e131::PreviewModeRequest*>(
      &::ola::plugin::e131::_PreviewModeRequest_default_instance_);
}
inline const ::ola::plugin::e131::PreviewModeRequest& Request::preview_mode() const {
  // @@protoc_insertion_point(field_get:ola.plugin.e131.Request.preview_mode)
  return _internal_preview_mode();
}
inline void Request::unsafe_arena_set_allocated_preview_mode(
    ::ola::plugin::e131::PreviewModeRequest* preview_mode) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(preview_mode_);
  }
  preview_mode_ = preview_mode;
  if (preview_mode) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ola.plugin.e131.Request.preview_mode)
}
inline ::ola::plugin::e131::PreviewModeRequest* Request::release_preview_mode() {
  auto temp = unsafe_arena_release_preview_mode();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ola::plugin::e131::PreviewModeRequest* Request::unsafe_arena_release_preview_mode() {
  // @@protoc_insertion_point(field_release:ola.plugin.e131.Request.preview_mode)
  _has_bits_[0] &= ~0x00000001u;
  ::ola::plugin::e131::PreviewModeRequest* temp = preview_mode_;
  preview_mode_ = nullptr;
  return temp;
}
inline ::ola::plugin::e131::PreviewModeRequest* Request::_internal_mutable_preview_mode() {
  _has_bits_[0] |= 0x00000001u;
  if (preview_mode_ == nullptr) {
    auto* p = CreateMaybeMessage<::ola::plugin::e131::PreviewModeRequest>(GetArena());
    preview_mode_ = p;
  }
  return preview_mode_;
}
inline ::ola::plugin::e131::PreviewModeRequest* Request::mutable_preview_mode() {
  // @@protoc_insertion_point(field_mutable:ola.plugin.e131.Request.preview_mode)
  return _internal_mutable_preview_mode();
}
inline void Request::set_allocated_preview_mode(::ola::plugin::e131::PreviewModeRequest* preview_mode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete preview_mode_;
  }
  if (preview_mode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(preview_mode);
    if (message_arena != submessage_arena) {
      preview_mode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, preview_mode, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  preview_mode_ = preview_mode;
  // @@protoc_insertion_point(field_set_allocated:ola.plugin.e131.Request.preview_mode)
}

// optional .ola.plugin.e131.SourceListRequest source_list = 3;
inline bool Request::_internal_has_source_list() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || source_list_ != nullptr);
  return value;
}
inline bool Request::has_source_list() const {
  return _internal_has_source_list();
}
inline void Request::clear_source_list() {
  if (source_list_ != nullptr) source_list_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ola::plugin::e131::SourceListRequest& Request::_internal_source_list() const {
  const ::ola::plugin::e131::SourceListRequest* p = source_list_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ola::plugin::e131::SourceListRequest*>(
      &::ola::plugin::e131::_SourceListRequest_default_instance_);
}
inline const ::ola::plugin::e131::SourceListRequest& Request::source_list() const {
  // @@protoc_insertion_point(field_get:ola.plugin.e131.Request.source_list)
  return _internal_source_list();
}
inline void Request::unsafe_arena_set_allocated_source_list(
    ::ola::plugin::e131::SourceListRequest* source_list) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_list_);
  }
  source_list_ = source_list;
  if (source_list) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ola.plugin.e131.Request.source_list)
}
inline ::ola::plugin::e131::SourceListRequest* Request::release_source_list() {
  auto temp = unsafe_arena_release_source_list();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ola::plugin::e131::SourceListRequest* Request::unsafe_arena_release_source_list() {
  // @@protoc_insertion_point(field_release:ola.plugin.e131.Request.source_list)
  _has_bits_[0] &= ~0x00000002u;
  ::ola::plugin::e131::SourceListRequest* temp = source_list_;
  source_list_ = nullptr;
  return temp;
}
inline ::ola::plugin::e131::SourceListRequest* Request::_internal_mutable_source_list() {
  _has_bits_[0] |= 0x00000002u;
  if (source_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::ola::plugin::e131::SourceListRequest>(GetArena());
    source_list_ = p;
  }
  return source_list_;
}
inline ::ola::plugin::e131::SourceListRequest* Request::mutable_source_list() {
  // @@protoc_insertion_point(field_mutable:ola.plugin.e131.Request.source_list)
  return _internal_mutable_source_list();
}
inline void Request::set_allocated_source_list(::ola::plugin::e131::SourceListRequest* source_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete source_list_;
  }
  if (source_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(source_list);
    if (message_arena != submessage_arena) {
      source_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_list, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  source_list_ = source_list;
  // @@protoc_insertion_point(field_set_allocated:ola.plugin.e131.Request.source_list)
}

// -------------------------------------------------------------------

// Reply

// required .ola.plugin.e131.Reply.ReplyType type = 1;
inline bool Reply::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Reply::has_type() const {
  return _internal_has_type();
}
inline void Reply::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::ola::plugin::e131::Reply_ReplyType Reply::_internal_type() const {
  return static_cast< ::ola::plugin::e131::Reply_ReplyType >(type_);
}
inline ::ola::plugin::e131::Reply_ReplyType Reply::type() const {
  // @@protoc_insertion_point(field_get:ola.plugin.e131.Reply.type)
  return _internal_type();
}
inline void Reply::_internal_set_type(::ola::plugin::e131::Reply_ReplyType value) {
  assert(::ola::plugin::e131::Reply_ReplyType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void Reply::set_type(::ola::plugin::e131::Reply_ReplyType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ola.plugin.e131.Reply.type)
}

// optional .ola.plugin.e131.PortInfoReply port_info = 2;
inline bool Reply::_internal_has_port_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || port_info_ != nullptr);
  return value;
}
inline bool Reply::has_port_info() const {
  return _internal_has_port_info();
}
inline void Reply::clear_port_info() {
  if (port_info_ != nullptr) port_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ola::plugin::e131::PortInfoReply& Reply::_internal_port_info() const {
  const ::ola::plugin::e131::PortInfoReply* p = port_info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ola::plugin::e131::PortInfoReply*>(
      &::ola::plugin::e131::_PortInfoReply_default_instance_);
}
inline const ::ola::plugin::e131::PortInfoReply& Reply::port_info() const {
  // @@protoc_insertion_point(field_get:ola.plugin.e131.Reply.port_info)
  return _internal_port_info();
}
inline void Reply::unsafe_arena_set_allocated_port_info(
    ::ola::plugin::e131::PortInfoReply* port_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(port_info_);
  }
  port_info_ = port_info;
  if (port_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ola.plugin.e131.Reply.port_info)
}
inline ::ola::plugin::e131::PortInfoReply* Reply::release_port_info() {
  auto temp = unsafe_arena_release_port_info();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ola::plugin::e131::PortInfoReply* Reply::unsafe_arena_release_port_info() {
  // @@protoc_insertion_point(field_release:ola.plugin.e131.Reply.port_info)
  _has_bits_[0] &= ~0x00000001u;
  ::ola::plugin::e131::PortInfoReply* temp = port_info_;
  port_info_ = nullptr;
  return temp;
}
inline ::ola::plugin::e131::PortInfoReply* Reply::_internal_mutable_port_info() {
  _has_bits_[0] |= 0x00000001u;
  if (port_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ola::plugin::e131::PortInfoReply>(GetArena());
    port_info_ = p;
  }
  return port_info_;
}
inline ::ola::plugin::e131::PortInfoReply* Reply::mutable_port_info() {
  // @@protoc_insertion_point(field_mutable:ola.plugin.e131.Reply.port_info)
  return _internal_mutable_port_info();
}
inline void Reply::set_allocated_port_info(::ola::plugin::e131::PortInfoReply* port_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete port_info_;
  }
  if (port_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(port_info);
    if (message_arena != submessage_arena) {
      port_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, port_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  port_info_ = port_info;
  // @@protoc_insertion_point(field_set_allocated:ola.plugin.e131.Reply.port_info)
}

// optional .ola.plugin.e131.SourceListReply source_list = 3;
inline bool Reply::_internal_has_source_list() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || source_list_ != nullptr);
  return value;
}
inline bool Reply::has_source_list() const {
  return _internal_has_source_list();
}
inline void Reply::clear_source_list() {
  if (source_list_ != nullptr) source_list_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ola::plugin::e131::SourceListReply& Reply::_internal_source_list() const {
  const ::ola::plugin::e131::SourceListReply* p = source_list_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ola::plugin::e131::SourceListReply*>(
      &::ola::plugin::e131::_SourceListReply_default_instance_);
}
inline const ::ola::plugin::e131::SourceListReply& Reply::source_list() const {
  // @@protoc_insertion_point(field_get:ola.plugin.e131.Reply.source_list)
  return _internal_source_list();
}
inline void Reply::unsafe_arena_set_allocated_source_list(
    ::ola::plugin::e131::SourceListReply* source_list) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_list_);
  }
  source_list_ = source_list;
  if (source_list) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ola.plugin.e131.Reply.source_list)
}
inline ::ola::plugin::e131::SourceListReply* Reply::release_source_list() {
  auto temp = unsafe_arena_release_source_list();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ola::plugin::e131::SourceListReply* Reply::unsafe_arena_release_source_list() {
  // @@protoc_insertion_point(field_release:ola.plugin.e131.Reply.source_list)
  _has_bits_[0] &= ~0x00000002u;
  ::ola::plugin::e131::SourceListReply* temp = source_list_;
  source_list_ = nullptr;
  return temp;
}
inline ::ola::plugin::e131::SourceListReply* Reply::_internal_mutable_source_list() {
  _has_bits_[0] |= 0x00000002u;
  if (source_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::ola::plugin::e131::SourceListReply>(GetArena());
    source_list_ = p;
  }
  return source_list_;
}
inline ::ola::plugin::e131::SourceListReply* Reply::mutable_source_list() {
  // @@protoc_insertion_point(field_mutable:ola.plugin.e131.Reply.source_list)
  return _internal_mutable_source_list();
}
inline void Reply::set_allocated_source_list(::ola::plugin::e131::SourceListReply* source_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete source_list_;
  }
  if (source_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(source_list);
    if (message_arena != submessage_arena) {
      source_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_list, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  source_list_ = source_list;
  // @@protoc_insertion_point(field_set_allocated:ola.plugin.e131.Reply.source_list)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace e131
}  // namespace plugin
}  // namespace ola

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ola::plugin::e131::Request_RequestType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ola::plugin::e131::Request_RequestType>() {
  return ::ola::plugin::e131::Request_RequestType_descriptor();
}
template <> struct is_proto_enum< ::ola::plugin::e131::Reply_ReplyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ola::plugin::e131::Reply_ReplyType>() {
  return ::ola::plugin::e131::Reply_ReplyType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_E131ConfigMessages_2eproto
